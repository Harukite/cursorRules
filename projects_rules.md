---
globs:
alwaysApply: true
---

## 核心工作原则

### 1. 新需求接入流程
- **方案先行**：用户提出新需求时，先进行技术方案讨论
- **确认后开发**：只有用户明确确认方案后，才开始具体的开发工作
- **架构考虑**：考虑多平台架构（Next.js 前端、NestJS 后端、Flutter 移动端、原生 Android/iOS、浏览器插件），明确功能归属和跨平台复用策略

### 2. 问题修复流程
- **全面分析**：修复前需全面分析问题，不能只修复表面症状
- **精准定位**：提供精准定位的解决方案，明确问题所在的模块（前端/后端/移动端/插件）
- **根因分析**：阐明故障的根本原因，避免类似问题再次发生
- **影响评估**：评估修复对其他模块和平台的影响

### 3. 开发规范

#### 代码质量
- **简洁优先**：明确意图而非聪明代码，选择简单明了的解决方案
- **避免过度设计**：不要过度设计，保证代码简洁易懂、简单实用
- **圈复杂度控制**：注意圈复杂度，代码尽可能复用
- **模块化设计**：注意模块设计，尽量使用设计模式
- **最小改动原则**：改动时最小化修改，尽量不修改到其他模块代码

#### 渐进式开发
- **研究先行**：从现有代码学习，先研究和规划，再开始实现
- **小步提交**：渐进式开发，小步提交，每次都能编译通过和测试通过
- **分阶段实现**：将复杂工作分解为 3-5 个阶段，逐步推进

#### 代码风格
- **可读性优先**：优先考虑可读性与可维护性
- **标准模式**：尽可能使用标准库和通用模式
- **项目适配**：适应项目实际情况，不强制套用不合适的模式
- **代码注释**：复杂逻辑需添加代码注释

### 4. 技术栈规范

#### 前端 (Next.js)
- **框架**：使用 Next.js 进行前端开发
- **UI 库**：使用 https://ui.shadcn.com/ 作为 UI 组件库
- **动效库**：使用 Framer Motion 实现页面交互动画（需要流畅）
- **3D 场景**：使用 Three.js 绘制 3D 场景（如需要）
- **表单校验**：所有 web 表单校验使用 zod
  - 使用 zod schema 定义返回类型
  - 导出由 schema 生成的类型

#### 后端 (NestJS)
- **框架**：开发后端服务使用 NestJS
- **类型安全**：使用 TypeScript，确保类型安全
- **API 设计**：遵循 RESTful 规范，或根据需求选择 GraphQL
- **数据验证**：所有接口入参必须使用 DTO 并进行校验（推荐 zod）

#### 移动端 (Flutter)
- **框架**：使用 Flutter 进行跨平台移动应用开发
- **状态管理**：使用 GetX 进行状态管理，充分利用其响应式编程和依赖注入特性
- **UI 规范**：遵循 Material Design 3 设计规范，确保 UI 一致性
- **性能优化**：注意 Widget 重建优化，使用 const 构造函数
- **平台适配**：考虑 Android 和 iOS 平台差异，使用 Platform 类或平台通道
- **包管理**：使用 pubspec.yaml 管理依赖，注意版本兼容性
- **代码组织**：遵循 Flutter 官方推荐的目录结构（lib/、assets/、test/）

#### 原生 Android
- **开发语言**：优先使用 Kotlin，如需要支持 Java
- **架构模式**：遵循 MVVM 或 Clean Architecture 架构模式
- **UI 框架**：使用 Jetpack Compose（优先）或传统 View 系统
- **异步处理**：使用 Kotlin Coroutines 和 Flow 处理异步操作
- **依赖注入**：使用 Hilt 或 Koin 进行依赖注入
- **网络请求**：使用 Retrofit + OkHttp 或 Ktor
- **数据存储**：使用 Room 数据库或 DataStore 进行本地存储
- **构建系统**：使用 Gradle 构建系统，注意 Gradle 版本兼容性

#### 原生 iOS
- **开发语言**：优先使用 Swift，如需要支持 Objective-C
- **架构模式**：遵循 MVVM 或 Clean Architecture 架构模式
- **UI 框架**：使用 SwiftUI（优先）或 UIKit
- **异步处理**：使用 async/await 或 Combine 框架处理异步操作
- **依赖管理**：使用 Swift Package Manager（优先）或 CocoaPods
- **网络请求**：使用 URLSession 或 Alamofire
- **数据存储**：使用 Core Data 或 SwiftData 进行本地存储
- **最低版本**：明确最低支持的 iOS 版本，合理使用新特性

#### 浏览器插件
- **插件类型**：支持 Chrome Extension（Manifest V3）或 Web Extension 标准
- **技术栈**：使用 TypeScript 开发，确保类型安全
- **UI 开发**：使用 React 或原生 HTML/CSS/JS 开发 popup 和 options 页面
- **消息传递**：使用 chrome.runtime.sendMessage 或 chrome.tabs.sendMessage 进行通信
- **权限管理**：最小化权限申请，明确说明权限用途
- **存储管理**：使用 chrome.storage API 存储数据，注意存储限制
- **内容脚本**：注意内容脚本与页面脚本的隔离，避免污染页面环境
- **背景脚本**：使用 Service Worker（Manifest V3）或 Background Page（Manifest V2）
- **跨域处理**：合理处理跨域请求，使用 host_permissions 配置

#### 部署 (Vercel)
- **部署配置**：考虑 Vercel 部署特性
- **环境变量**：合理使用环境变量，不硬编码敏感信息
- **构建优化**：注意 Next.js 的构建优化配置

### 5. 学习现有代码库
- **模式识别**：理解现有模式，研究代码库中的 2-3 个相似功能/组件
- **通用模式**：识别通用模式，找出项目约定和模式
- **遵循规范**：遵循特定语言的规范与风格指南（TypeScript/React/NestJS/Dart/Kotlin/Swift）
- **跨平台复用**：识别可复用的业务逻辑，考虑共享代码策略

### 6. 特殊场景处理

#### 钱包交互脚本
- **多账号支持**：开发钱包交互脚本时，要考虑多号的情况
- **代理支持**：使用多代理的情况
- **接口审查**：做好浏览器的抓包，严格审查接口请求的入参，并适时用到代码中

#### 命令行脚本
- **增强可读性**：使用 emoji 图标（✅、❌、⏸️、📦、🔗、🌐）增强可读性
- **状态反馈**：加上一些状态 loading 样式
- **颜色区分**：文字做好对应的颜色区分
- **语言选择**：开发语言由用户决定，不能擅自作主

#### 跨平台开发
- **代码复用**：优先考虑跨平台代码复用（如 Flutter、共享 API 客户端）
- **平台特性**：合理利用各平台原生特性，不强制统一实现
- **版本管理**：保持各平台版本同步，明确版本依赖关系

### 7. 沟通与文档
- **简洁清晰**：解释说明力求简洁清晰
- **修改说明**：提供修改内容的简要说明
- **禁止项**：禁止自动生成 md 文档或无意义测试代码
- **适度测试**：提倡为新代码编写测试用例，但不要生成不必要的测试文件

### 8. 学习指导
- **概念解释**：根据要求解释相关概念
- **代码示例**：提供具体的代码示例帮助理解
- **延伸资源**：适时提供延伸学习资源

### 9. 语言规范
- **中文交流**：Always responds in 中文
- **英文搜索**：Always search in English

## 工作流程总结
1. **需求 → 方案讨论 → 确认 → 研究现有代码 → 分阶段实现 → 测试 → 提交**
2. **问题 → 全面分析 → 精准定位 → 根因分析 → 最小改动修复 → 验证**
3. **开发 → 简洁代码 → 模块化设计 → 渐进提交 → 保持可维护性**

## 注意事项
- 始终结合具体项目的上下文环境和特殊要求进行考量
- 优先保证代码质量和可维护性
- 保持与用户的良好沟通，及时反馈进度和问题
- 跨平台开发时，注意各平台的特性差异和最佳实践
